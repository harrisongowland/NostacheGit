"use strict";
/**
 * Source code is adapted from
 * https://github.com/webpack-contrib/webpack-hot-middleware#readme
 * and rewritten in TypeScript. This file is MIT licensed
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.webpackHotMiddleware = void 0;
const types_1 = require("./types");
const url_1 = require("url");
const pathMatch = function (url, path) {
    try {
        return (0, url_1.parse)(url).pathname === path;
    }
    catch (e) {
        return false;
    }
};
const webpackHotMiddleware = (compiler) => {
    let eventStream = createEventStream(types_1.hotMiddlewareOptions.heartbeat);
    let latestStats = null;
    let closed = false;
    compiler.hooks.invalid.tap('webpack-hot-middleware', onInvalid);
    compiler.hooks.done.tap('webpack-hot-middleware', onDone);
    function onInvalid() {
        if (closed)
            return;
        latestStats = null;
        types_1.hotMiddlewareOptions.log('webpack building...');
        eventStream === null || eventStream === void 0 ? void 0 : eventStream.publish({
            action: 'building',
        });
    }
    function onDone(statsResult) {
        if (closed)
            return;
        // Keep hold of latest stats so they can be propagated to new clients
        latestStats = statsResult;
        publishStats('built', latestStats, eventStream, types_1.hotMiddlewareOptions.log);
    }
    const middleware = function (req, res, next) {
        if (closed)
            return next();
        if (!pathMatch(req.url, types_1.hotMiddlewareOptions.path))
            return next();
        eventStream === null || eventStream === void 0 ? void 0 : eventStream.handler(req, res);
        if (latestStats) {
            publishStats('sync', latestStats, eventStream, types_1.hotMiddlewareOptions.log);
        }
    };
    middleware.publish = function (payload) {
        if (closed)
            return;
        eventStream === null || eventStream === void 0 ? void 0 : eventStream.publish(payload);
    };
    middleware.close = function () {
        if (closed)
            return;
        // Can't remove compiler plugins, so we just set a flag and noop if closed
        // https://github.com/webpack/tapable/issues/32#issuecomment-350644466
        closed = true;
        eventStream === null || eventStream === void 0 ? void 0 : eventStream.close();
        eventStream = null;
    };
    return middleware;
};
exports.webpackHotMiddleware = webpackHotMiddleware;
function createEventStream(heartbeat) {
    let clientId = 0;
    let clients = {};
    function everyClient(fn) {
        Object.keys(clients).forEach((id) => {
            fn(clients[id]);
        });
    }
    const interval = setInterval(() => {
        everyClient((client) => {
            client.write('data: \uD83D\uDC93\n\n');
        });
    }, heartbeat).unref();
    return {
        close() {
            clearInterval(interval);
            everyClient((client) => {
                if (!client.finished)
                    client.end();
            });
            clients = {};
        },
        handler(req, res) {
            const headers = {
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'text/event-stream;charset=utf-8',
                'Cache-Control': 'no-cache, no-transform',
                // While behind nginx, event stream should not be buffered:
                // http://nginx.org/docs/http/ngx_http_proxy_module.html#proxy_buffering
                'X-Accel-Buffering': 'no',
            };
            const isHttp1 = !(parseInt(req.httpVersion, 10) >= 2);
            if (isHttp1) {
                req.socket.setKeepAlive(true);
                Object.assign(headers, {
                    Connection: 'keep-alive',
                });
            }
            res.writeHead(200, headers);
            res.write('\n');
            const id = clientId++;
            clients[id] = res;
            req.on('close', () => {
                if (!res.finished)
                    res.end();
                delete clients[id];
            });
        },
        publish(payload) {
            everyClient((client) => {
                client.write('data: ' + JSON.stringify(payload) + '\n\n');
            });
        },
    };
}
function publishStats(action, statsResult, eventStream, log) {
    const stats = statsResult.toJson({
        all: false,
        cached: true,
        children: true,
        modules: true,
        timings: true,
        hash: true,
    });
    // For multi-compiler, stats will be an object with a 'children' array of stats
    const bundles = extractBundles(stats);
    bundles.forEach((_stats) => {
        let name = _stats.name || '';
        // Fallback to compilation name in case of 1 bundle (if it exists)
        if (bundles.length === 1 && !name && statsResult.compilation) {
            name = statsResult.compilation.name || '';
        }
        if (log) {
            log('webpack built ' +
                (name ? name + ' ' : '') +
                _stats.hash +
                ' in ' +
                _stats.time +
                'ms');
        }
        eventStream === null || eventStream === void 0 ? void 0 : eventStream.publish({
            name,
            action,
            time: _stats.time,
            hash: _stats.hash,
            warnings: _stats.warnings || [],
            errors: _stats.errors || [],
            modules: buildModuleMap(_stats.modules),
        });
    });
}
function extractBundles(stats) {
    var _a;
    // Stats has modules, single bundle
    if (stats.modules)
        return [stats];
    // Stats has children, multiple bundles
    if ((_a = stats.children) === null || _a === void 0 ? void 0 : _a.length)
        return stats.children;
    // Not sure, assume single
    return [stats];
}
function buildModuleMap(modules) {
    const map = {};
    if (!modules) {
        return map;
    }
    modules.forEach((module) => {
        const id = module.id;
        map[id] = module.name;
    });
    return map;
}
//# sourceMappingURL=index.js.map