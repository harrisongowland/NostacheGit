"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilenameFromUrl = void 0;
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
// eslint-disable-next-line no-restricted-imports
const querystring_1 = __importDefault(require("querystring"));
const get_paths_1 = require("./get-paths");
const cacheStore = new WeakMap();
const mem = (fn, { cache = new Map() } = {}) => {
    const memoized = (...arguments_) => {
        const [key] = arguments_;
        const cacheItem = cache.get(key);
        if (cacheItem) {
            return cacheItem.data;
        }
        const result = fn.apply(this, arguments_);
        cache.set(key, {
            data: result,
        });
        return result;
    };
    cacheStore.set(memoized, cache);
    return memoized;
};
const memoizedParse = mem(url_1.parse);
function getFilenameFromUrl(context, url) {
    var _a, _b;
    const paths = (0, get_paths_1.getPaths)(context);
    let foundFilename;
    let urlObject;
    try {
        // The `url` property of the `request` is contains only  `pathname`, `search` and `hash`
        urlObject = memoizedParse(url, false, true);
    }
    catch (_ignoreError) {
        return;
    }
    for (const { publicPath, outputPath } of paths) {
        let filename;
        let publicPathObject;
        try {
            publicPathObject = memoizedParse(publicPath !== 'auto' && publicPath ? publicPath : '/', false, true);
        }
        catch (_ignoreError) {
            continue;
        }
        if ((_a = urlObject.pathname) === null || _a === void 0 ? void 0 : _a.startsWith(publicPathObject.pathname)) {
            filename = outputPath;
            // Strip the `pathname` property from the `publicPath` option from the start of requested url
            // `/complex/foo.js` => `foo.js`
            const pathname = urlObject.pathname.substr(publicPathObject.pathname.length);
            if (pathname) {
                filename = path_1.default.join(outputPath, querystring_1.default.unescape(pathname));
            }
            if (!context.outputFileSystem) {
                continue;
            }
            try {
                let fsStats = (_b = context.outputFileSystem) === null || _b === void 0 ? void 0 : _b.statSync(filename);
                if (fsStats.isFile()) {
                    foundFilename = filename;
                    break;
                }
                else if (fsStats.isDirectory()) {
                    const indexValue = 'index.html';
                    filename = path_1.default.join(filename, indexValue);
                    // eslint-disable-next-line max-depth
                    try {
                        fsStats = context.outputFileSystem.statSync(filename);
                    }
                    catch (__ignoreError) {
                        continue;
                    }
                    // eslint-disable-next-line max-depth
                    if (fsStats.isFile()) {
                        foundFilename = filename;
                        break;
                    }
                }
            }
            catch (_ignoreError) {
                continue;
            }
        }
    }
    return foundFilename;
}
exports.getFilenameFromUrl = getFilenameFromUrl;
//# sourceMappingURL=get-filename-from-url.js.map