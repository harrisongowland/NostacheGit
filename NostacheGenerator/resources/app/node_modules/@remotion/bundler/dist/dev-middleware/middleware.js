"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.middleware = void 0;
const ready_1 = require("./ready");
const path_1 = __importDefault(require("path"));
const get_filename_from_url_1 = require("./get-filename-from-url");
const compatible_api_1 = require("./compatible-api");
const mime_types_1 = __importDefault(require("mime-types"));
const range_parser_1 = require("./range-parser");
function getValueContentRangeHeader(type, size, range) {
    return `${type} ${range ? `${range.start}-${range.end}` : '*'}/${size}`;
}
function createHtmlDocument(title, body) {
    return (`${'<!DOCTYPE html>\n' +
        '<html lang="en">\n' +
        '<head>\n' +
        '<meta charset="utf-8">\n' +
        '<title>'}${title}</title>\n` +
        `</head>\n` +
        `<body>\n` +
        `<pre>${body}</pre>\n` +
        `</body>\n` +
        `</html>\n`);
}
const BYTES_RANGE_REGEXP = /^ *bytes/i;
function middleware(context) {
    return async function (req, res, next) {
        const acceptedMethods = ['GET', 'HEAD'];
        // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.
        res.locals = res.locals || {};
        if (req.method && !acceptedMethods.includes(req.method)) {
            await goNext();
            return;
        }
        (0, ready_1.ready)(context, processRequest, req);
        function goNext() {
            return next();
        }
        async function processRequest() {
            var _a;
            const filename = (0, get_filename_from_url_1.getFilenameFromUrl)(context, req.url);
            if (!filename) {
                await goNext();
                return;
            }
            /**
             * @type {{key: string, value: string | number}[]}
             */
            if (!(0, compatible_api_1.getHeaderFromResponse)(res, 'Content-Type')) {
                // content-type name(like application/javascript; charset=utf-8) or false
                const contentType = mime_types_1.default.contentType(path_1.default.extname(filename));
                // Only set content-type header if media type is known
                // https://tools.ietf.org/html/rfc7231#section-3.1.1.5
                if (contentType) {
                    (0, compatible_api_1.setHeaderForResponse)(res, 'Content-Type', contentType);
                }
            }
            if (!(0, compatible_api_1.getHeaderFromResponse)(res, 'Accept-Ranges')) {
                (0, compatible_api_1.setHeaderForResponse)(res, 'Accept-Ranges', 'bytes');
            }
            const rangeHeader = (0, compatible_api_1.getHeaderFromRequest)(req, 'range');
            let start;
            let end;
            if (rangeHeader &&
                BYTES_RANGE_REGEXP.test(rangeHeader) &&
                context.outputFileSystem) {
                const size = await new Promise((resolve) => {
                    var _a;
                    (_a = context.outputFileSystem) === null || _a === void 0 ? void 0 : _a.lstat(filename, (error, stats) => {
                        var _a;
                        if (error) {
                            context.logger.error(error);
                            return;
                        }
                        resolve((_a = stats === null || stats === void 0 ? void 0 : stats.size) !== null && _a !== void 0 ? _a : 0);
                    });
                });
                const parsedRanges = (0, range_parser_1.parseRange)(size, rangeHeader);
                if (parsedRanges === -1) {
                    const message = "Unsatisfiable range for 'Range' header.";
                    context.logger.error(message);
                    const existingHeaders = (0, compatible_api_1.getHeaderNames)(res);
                    for (let i = 0; i < existingHeaders.length; i++) {
                        res.removeHeader(existingHeaders[i]);
                    }
                    (0, compatible_api_1.setStatusCode)(res, 416);
                    (0, compatible_api_1.setHeaderForResponse)(res, 'Content-Range', getValueContentRangeHeader('bytes', size));
                    (0, compatible_api_1.setHeaderForResponse)(res, 'Content-Type', 'text/html; charset=utf-8');
                    const document = createHtmlDocument(416, `Error: ${message}`);
                    const _byteLength = Buffer.byteLength(document);
                    (0, compatible_api_1.setHeaderForResponse)(res, 'Content-Length', Buffer.byteLength(document));
                    (0, compatible_api_1.send)(req, res, document, _byteLength);
                    return;
                }
                if (parsedRanges === -2) {
                    context.logger.error("A malformed 'Range' header was provided. A regular response will be sent for this request.");
                }
                else if (parsedRanges.length > 1) {
                    context.logger.error("A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.");
                }
                if (parsedRanges !== -2 && parsedRanges.length === 1) {
                    // Content-Range
                    (0, compatible_api_1.setStatusCode)(res, 206);
                    (0, compatible_api_1.setHeaderForResponse)(res, 'Content-Range', getValueContentRangeHeader('bytes', size, parsedRanges[0]));
                    [{ start, end }] = parsedRanges;
                }
            }
            const isFsSupportsStream = typeof ((_a = context.outputFileSystem) === null || _a === void 0 ? void 0 : _a.createReadStream) === 'function';
            let bufferOtStream;
            let byteLength = 0;
            try {
                if (typeof start !== 'undefined' &&
                    typeof end !== 'undefined' &&
                    isFsSupportsStream &&
                    context.outputFileSystem) {
                    bufferOtStream = context.outputFileSystem.createReadStream(filename, {
                        start,
                        end,
                    });
                    byteLength = end - start + 1;
                }
                else if (context.outputFileSystem) {
                    bufferOtStream = context.outputFileSystem.readFileSync(filename);
                    // @ts-expect-error
                    byteLength = bufferOtStream.byteLength;
                }
            }
            catch (_ignoreError) {
                await goNext();
                return;
            }
            if (bufferOtStream) {
                (0, compatible_api_1.send)(req, res, bufferOtStream, byteLength);
            }
        }
    };
}
exports.middleware = middleware;
//# sourceMappingURL=middleware.js.map